package api

import "encoding/json"

func BuildSpec() ([]byte, error) {
	paths := map[string]any{}

	for _, p := range GetPaths() {
		props := ReflectModel(p.Model)
		// Remove id from POST request body
		if p.Method == "post" {
			delete(props, "id")
		}
		// Mark id as readOnly for PUT
		if p.Method == "put" {
			if v, ok := props["id"].(map[string]string); ok {
				props["id"] = map[string]any{
					"type":     v["type"],
					"readOnly": true,
				}
			}
		}
		pathItem := paths[p.Path]
		if pathItem == nil {
			pathItem = map[string]any{}
			paths[p.Path] = pathItem
		}

		// Detect if path has a parameter (e.g., {id})
		var parameters []map[string]any
		if paramName := extractPathParam(p.Path); paramName != "" {
			parameters = append(parameters, map[string]any{
				"name":     paramName,
				"in":       "path",
				"required": true,
				"schema": map[string]any{
					"type": "string",
				},
			})
		}

		methodSpec := map[string]any{
			"summary": "Autogenerated by Bridgr",
			"responses": map[string]any{
				"200": map[string]any{
					"description": "Success",
				},
			},
		}
		if len(parameters) > 0 {
			methodSpec["parameters"] = parameters
		}
		if p.Method == "post" || p.Method == "put" {
			methodSpec["requestBody"] = map[string]any{
				"content": map[string]any{
					"application/json": map[string]any{
						"schema": map[string]any{
							"type":       "object",
							"properties": props,
						},
					},
				},
			}
		}
		pathItem.(map[string]any)[p.Method] = methodSpec
	}

	doc := map[string]any{
		"openapi": "3.0.0",
		"info": map[string]string{
			"title":   "Bridgr API",
			"version": "1.0.0",
		},
		"paths": paths,
	}
	return json.MarshalIndent(doc, "", "  ")
}

// extractPathParam returns the parameter name if the path contains {param}, else "".
func extractPathParam(path string) string {
	start := -1
	end := -1
	for i, c := range path {
		if c == '{' {
			start = i + 1
		}
		if c == '}' && start != -1 {
			end = i
			break
		}
	}
	if start != -1 && end != -1 && end > start {
		return path[start:end]
	}
	return ""
}
