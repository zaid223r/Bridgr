package api

import (
	"encoding/json"
	"reflect"
)

func BuildSpec() ([]byte, error) {
	paths := map[string]any{}

	for _, p := range GetPaths() {
		props := ReflectModel(p.Model)
		// Remove id from POST request body
		if p.Method == "post" {
			delete(props, "id")
		}
		// Mark id as readOnly for PUT
		if p.Method == "put" {
			if v, ok := props["id"].(map[string]string); ok {
				props["id"] = map[string]any{
					"type":     v["type"],
					"readOnly": true,
				}
			}
		}
		pathItem := paths[p.Path]
		if pathItem == nil {
			pathItem = map[string]any{}
			paths[p.Path] = pathItem
		}

		// Detect if path has a parameter (e.g., {id})
		var parameters []map[string]any
		if paramName := extractPathParam(p.Path); paramName != "" {
			parameters = append(parameters, map[string]any{
				"name":     paramName,
				"in":       "path",
				"required": true,
				"schema": map[string]any{
					"type": "string",
				},
			})
		}

		// Add filterable fields as query parameters for GET list endpoints
		if p.Method == "get" && extractPathParam(p.Path) == "" {
			for _, name := range getFilterableFieldNames(p.Model) {
				fieldType := getFieldTypeByJSONTag(p.Model, name)
				parameters = append(parameters, map[string]any{
					"name":     name,
					"in":       "query",
					"required": false,
					"schema": map[string]any{
						"type": fieldType,
					},
				})
			}
		}

		methodSpec := map[string]any{
			"summary": "Autogenerated by Bridgr",
			"responses": map[string]any{
				"200": map[string]any{
					"description": "Success",
				},
			},
		}
		if len(parameters) > 0 {
			methodSpec["parameters"] = parameters
		}
		if p.Method == "post" || p.Method == "put" {
			methodSpec["requestBody"] = map[string]any{
				"content": map[string]any{
					"application/json": map[string]any{
						"schema": map[string]any{
							"type":       "object",
							"properties": props,
						},
					},
				},
			}
		}
		pathItem.(map[string]any)[p.Method] = methodSpec
	}

	doc := map[string]any{
		"openapi": "3.0.0",
		"info": map[string]string{
			"title":   "Bridgr API",
			"version": "1.0.0",
		},
		"paths": paths,
	}
	return json.MarshalIndent(doc, "", "  ")
}

// extractPathParam returns the parameter name if the path contains {param}, else "".
func extractPathParam(path string) string {
	start := -1
	end := -1
	for i, c := range path {
		if c == '{' {
			start = i + 1
		}
		if c == '}' && start != -1 {
			end = i
			break
		}
	}
	if start != -1 && end != -1 && end > start {
		return path[start:end]
	}
	return ""
}

// getFilterableFieldNames returns a slice of filterable field names for a model instance
func getFilterableFieldNames(model any) []string {
	typeOf := reflect.TypeOf(model)
	if typeOf.Kind() == reflect.Ptr {
		typeOf = typeOf.Elem()
	}
	var names []string
	var allFields = map[string]struct{}{}
	for i := 0; i < typeOf.NumField(); i++ {
		f := typeOf.Field(i)
		jsonName := f.Tag.Get("json")
		if jsonName == "" {
			jsonName = f.Name
		}
		allFields[jsonName] = struct{}{}
	}
	// Check for GenericFiltering() bool
	if _, ok := reflect.TypeOf(model).MethodByName("GenericFiltering"); ok {
		result := reflect.ValueOf(model).MethodByName("GenericFiltering").Call(nil)
		if len(result) == 1 && result[0].Bool() {
			for field := range allFields {
				names = append(names, field)
			}
			return names
		}
	}
	// Otherwise, check for FilterableFields()
	if _, ok := reflect.TypeOf(model).MethodByName("FilterableFields"); ok {
		vals := reflect.ValueOf(model).MethodByName("FilterableFields").Call(nil)
		if len(vals) > 0 {
			for _, v := range vals[0].Interface().([]string) {
				if _, exists := allFields[v]; !exists {
					panic("FilterableFields error: field '" + v + "' does not exist in struct " + typeOf.Name())
				}
				names = append(names, v)
			}
		}
	}
	return names
}

func getFieldTypeByJSONTag(model any, jsonTag string) string {
	t := reflect.TypeOf(model)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		tag := f.Tag.Get("json")
		if tag == jsonTag || (tag == "" && f.Name == jsonTag) {
			switch f.Type.Kind() {
			case reflect.Bool:
				return "boolean"
			case reflect.Int, reflect.Int64, reflect.Int32, reflect.Int16, reflect.Int8,
				reflect.Uint, reflect.Uint64, reflect.Uint32, reflect.Uint16, reflect.Uint8:
				return "integer"
			case reflect.Float32, reflect.Float64:
				return "number"
			case reflect.String:
				return "string"
			}
		}
	}
	return "string"
}
